# @Time    : 2021/9/8 下午8:45
# @Author  : WenLong
# @Email   : 47407469@qq.com
# @File    : trajectory_planning_func.py
# @Software: PyCharm
# !/usr/bin/env python
# -*- coding:utf-8 -*-
# project:    deploy
# author:     OldYoung
# datetime:  2020/9/14 9:52

import numpy as np
import math
from matplotlib import pyplot as ply


class Coordinate:
    def __init__(self):
        pass

    @staticmethod
    def transfercoordinate(heading: float = 0.0) -> np.ndarray:
        '''
        TODO: 坐标转换矩阵，输入为局部坐标系相对全局坐标系的航向角，
        X = AX' +X0#X'为局部坐标系下的点集合, X为全局坐标系下的点集合，
        X0为X'原点在X坐标系中的全局坐标位置。
        默认X为列向量，X为行向量的时候，需要将A进行转置
        :param heading: [rad]
        :return:
        '''
        return np.array([[math.cos(heading), -math.sin(heading)],
                         [math.sin(heading), math.cos(heading)]])


def sgn(x: float):
    return 1 if x >= 0 else -1


class Deploy:
    def __init__(self, x: float = 100, y: float = 10, heading=-math.pi / 6):
        self.radius1 = 20
        self.radius2 = 20
        self.P0g: np.ndarray = np.array([[x], [y]])
        self.heading = heading
        self.angle2 = 0.0
        self.angle3 = 0.0
        self.e = 0.0
        self.P1g: np.ndarray = np.array([[0], [0]])
        self.P2g: np.ndarray = np.array([[0], [0]])
        self.P3g: np.ndarray = np.array([[0], [0]])
        self.P4g: np.ndarray = np.array([[0], [0]])
        self.length1 = 0.0
        self.length2 = 0.0
        self.length3 = 0.0
        self.length4 = 0.0

        self.vel: float = 4
        self.acc: float = 1
        self.accDist: float = 0.0
        self.timeStep: float = 0.1
        self.autoGenerated = False

        self.getFirstPoint()
        self.getSecondPoint()
        self.getThirdPoint()
        self.getLastPoint()

    def getFirstPoint(self):
        self.R1 = self.radius1 * sgn(self.heading)
        self.O1lx = 0
        self.O1ly = self.R1
        self.P1lx = self.O1lx - self.R1 * math.sin(self.heading)
        self.P1ly = self.O1ly - self.R1 * math.cos(self.heading)
        self.P1g = np.dot(Coordinate.transfercoordinate(self.heading), np.array([[self.P1lx], [self.P1ly]])) + self.P0g
        self.length1 = self.radius1 * abs(self.heading)

    def getSecondPoint(self):
        self.e: float = self.P1g[1][0]
        self.R2 = - self.radius2 * sgn(self.e)
        assert abs(self.e) <= 4 * abs(self.R2), "acos函数没有解"
        self.O2lx = 0
        self.O2ly = self.R2
        self.angle2 = - math.acos(1 - abs(self.e) / (2 * abs(self.R2) + math.pow(10, -5))) * sgn(self.e)
        self.P2lx = self.O2lx - self.R2 * math.sin(self.angle2)
        self.P2ly = self.O2ly - self.R2 * math.cos(self.angle2)
        self.P2g: np.ndarray = np.dot(Coordinate.transfercoordinate(0), np.array([[self.P2lx], [self.P2ly]])) + self.P1g
        self.length2 = self.radius2 * abs(self.angle2)

    def getThirdPoint(self):
        self.R3 = - self.R2
        self.angle3 = -self.angle2
        self.O3lx = 0
        self.O3ly = self.R3
        self.P3lx = self.O3lx - self.R3 * math.sin(self.angle3)
        self.P3ly = self.O3ly - self.R3 * math.cos(self.angle3)
        self.P3g = np.dot(Coordinate.transfercoordinate(self.angle3), np.array([[self.P3lx], [self.P3ly]])) + self.P2g
        self.length3 = self.length2

    def getLastPoint(self):
        self.P4g = np.array([[0], [0]])
        self.length4 = float(self.P3g[0][0]) - float(self.P4g[0][0])

    def checkPoints(self):
        assert self.P3g[0][0] >= self.P4g[0][0], "轨迹未能生成"

    def getHeadingandXY(self, distance: float) -> tuple:
        if distance >= 0 and distance < self.length1:
            angle = distance / self.R1
            RP1lx = self.O1lx - self.R1 * math.sin(angle)
            RP1ly = self.O1ly - self.R1 * math.cos(angle)
            RP1g = np.dot(Coordinate.transfercoordinate(self.heading),
                          np.array([[RP1lx], [RP1ly]])) + self.P0g
            heading, X, Y = self.heading - angle, RP1g[0][0], RP1g[1][0]
        elif distance >= self.length1 and distance < self.length2 + self.length1:
            angle = (distance - self.length1) / self.R2
            RP2lx = self.O2lx - self.R2 * math.sin(angle)
            RP2ly = self.O2ly - self.R2 * math.cos(angle)
            RP2g: np.ndarray = np.dot(Coordinate.transfercoordinate(0),
                                      np.array([[RP2lx], [RP2ly]])) + self.P1g
            heading, X, Y = -angle, RP2g[0][0], RP2g[1][0]
        elif distance >= self.length1 + self.length2 and distance < self.length2 + self.length1 + self.length3:
            angle = (distance - self.length1 - self.length2) / self.R3
            RP3lx = self.O3lx - self.R3 * math.sin(angle)
            RP3ly = self.O3ly - self.R3 * math.cos(angle)
            RP3g: np.ndarray = np.dot(Coordinate.transfercoordinate(self.angle3),
                                      np.array([[RP3lx], [RP3ly]])) + self.P2g
            heading, X, Y = -self.angle2 - angle, RP3g[0][0], RP3g[1][0]
        elif distance >= self.length2 + self.length1 + self.length3 and distance < self.length2 + self.length1 + self.length3 + self.length4:
            heading, Y, X = 0.0, 0.0, self.length4 - (distance - self.length2 - self.length1 - self.length3)
        else:
            heading, X, Y = 0.0, 0.0, 0.0
        return heading * 180 / math.pi, X, Y

    def arrangeMove(self):
        self.totoalDist = self.length1 + self.length2 + self.length3 + self.length4
        self.accDist = self.vel ** 2 / (2 * self.acc)
        if 2 * self.accDist > self.totoalDist:
            self.autoGenerated = False
        else:
            self.autoGenerated = True
            accIters = round(self.vel / (self.acc * self.timeStep))
            constIters = round((self.totoalDist - 2 * self.accDist) / (self.vel * self.timeStep))

            self.trajectory = np.zeros(shape=(2 * accIters + constIters + 1, 10), dtype=float)
            for i in range(accIters + 1):
                timeStamp = i * self.timeStep
                distance = 0.5 * self.acc * timeStamp ** 2
                velocity = self.acc * timeStamp
                heading, X, Y = self.getHeadingandXY(distance)
                self.trajectory[i, :] = np.array([X, Y, velocity, heading, 0, 0, timeStamp, self.acc, distance, 0])
            for i in range(accIters + 1, accIters + constIters + 1):
                timeStamp = i * self.timeStep
                distance = self.vel * (timeStamp - accIters * self.timeStep) + self.trajectory[accIters, 8]
                velocity = self.vel
                heading, X, Y = self.getHeadingandXY(distance)
                self.trajectory[i, :] = np.array([X, Y, velocity, heading, 0, 0, timeStamp, 0, distance, 1])
            for i in range(accIters + constIters + 1, 2 * accIters + constIters + 1):
                timeStamp = i * self.timeStep
                distance = self.vel * (timeStamp - (accIters + constIters) * self.timeStep) + \
                           1 / 2 * (-self.acc) * (timeStamp - (accIters + constIters) * self.timeStep) ** 2 + \
                           self.trajectory[accIters + constIters, 8]
                velocity = self.vel - self.acc * (timeStamp - (accIters + constIters) * self.timeStep)
                heading, X, Y = self.getHeadingandXY(distance)
                self.trajectory[i, :] = np.array([X, Y, velocity, heading, 0, 0, timeStamp, -self.acc, distance, 2])


if __name__ == '__main__':
    deploy = Deploy(100, -50, -math.pi / 2)
    deploy.arrangeMove()
    deploy.checkPoints()
    ply.scatter([deploy.P0g[0][0], deploy.P1g[0][0], deploy.P2g[0][0], deploy.P3g[0][0], deploy.P4g[0][0]],
                [deploy.P0g[1][0], deploy.P1g[1][0], deploy.P2g[1][0], deploy.P3g[1][0], deploy.P4g[1][0]])
    ply.plot(deploy.trajectory[:, 0].tolist(), deploy.trajectory[:, 1].tolist())
    ply.show()


